
[{"content":"","date":"3 March 2025","description":"","externalUrl":null,"permalink":"/blog/","section":"Blogs","summary":"","title":"Blogs","type":"blog"},{"content":"","date":"3 March 2025","description":"","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"\rOverview\r#\rHere are some of the challenges that I solved during PwnMe CTF 2025:\nRev\r#\rBack to the past\r#\rUsing the provided binary and the encrypted file, find a way to retrieve the flag contained in \u0026ldquo;flag.enc\u0026rdquo;. Note that the binary would have been run in May 2024. Note: The flag is in the format PWNME{\u0026hellip;}\nAuthor : Fayred\nFlag format: PWNME{.........................}\nWe are given a binary executable that encrypts the flag file.\neenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ ./backToThePast Usage: ./backToThePast \u0026lt;filename\u0026gt; eenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ echo 1234 \u0026gt; test eenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ ./backToThePast test time : 1740925301\rRunning the binary, we see that it prints out the current timestamp. So it might use the timestamp for encryption. Let\u0026rsquo;s check that in IDA:\nDetails int __fastcall main(int argc, const char **argv, const char **envp) { char v3; // cl int v5; // edx char v6; // cl int v7; // edx char v8; // cl int v9; // eax char v10; // cl int v11; // [rsp+1Ch] [rbp-124h] unsigned int v12; // [rsp+20h] [rbp-120h] __int64 v13; // [rsp+28h] [rbp-118h] char v14[264]; // [rsp+30h] [rbp-110h] BYREF unsigned __int64 v15; // [rsp+138h] [rbp-8h] v15 = __readfsqword(0x28u); if ( argc \u0026gt; 1 ) { v12 = time(0LL, argv, envp); printf((unsigned int)\u0026#34;time : %ld\\n\u0026#34;, v12, v5, v6); srand(v12); v13 = fopen64(argv[1], \u0026#34;rb+\u0026#34;); if ( v13 ) { while ( 1 ) { v11 = getc(v13); if ( v11 == 0xFFFFFFFF ) { break; } fseek(v13, 0xFFFFFFFFFFFFFFFFLL, 1LL); v9 = rand(); fputc(v11 ^ (unsigned int)(v9 % 0x7F), v13); } fclose(v13); strcpy(v14, argv[1]); strcat(v14, \u0026#34;.enc\u0026#34;); if ( (unsigned int)rename(argv[1], v14) ) { printf( (unsigned int)\u0026#34;Can\u0026#39;t rename %s filename to %s.enc\u0026#34;, (unsigned int)argv[1], (unsigned int)argv[1], v10); return 1; } else { return 0; } } else { printf((unsigned int)\u0026#34;Can\u0026#39;t open file %s\\n\u0026#34;, (unsigned int)argv[1], v7, v8); return 1; } } else { printf((unsigned int)\u0026#34;Usage: %s \u0026lt;filename\u0026gt;\\n\u0026#34;, (unsigned int)*argv, (_DWORD)envp, v3); return 1; } }\rIndeed, it uses the timestamp to set seed, then XOR our file with random numbers and write it to a .enc file.\nThings should be easy enough. However, when I tried to write a solve script using libc\u0026rsquo;s random, it didn\u0026rsquo;t give the right result. After debugging, I noticed that the random numbers of the program were different from mine. So something has been changed ðŸ¤”.\nIt turns out the srand and rand functions are not the standard libc functions, but rather custom functions:\n__int64 __fastcall srand(int a1) { __int64 result; // rax result = (unsigned int)(a1 - 1); seed = result; return result; }\runsigned __int64 rand() { seed = 0x5851F42D4C957F2DLL * seed + 1; return (unsigned __int64)seed \u0026gt;\u0026gt; 0x21; }\rThe srand function actually sets the seed to be equal to a1 - 1. I\u0026rsquo;m not sure if rand is different from the standard one, but we\u0026rsquo;ll not care about that.\nFrom this, I wrote a quick script to solve the challenge. Given that the challenge\u0026rsquo;s description said the binary would have been run in May 2024, I bruteforced the timestamp from May to June:\ndata = open(\u0026#34;flag.enc\u0026#34;, \u0026#39;rb\u0026#39;).read() seed = 1740845724 def srand(s): global seed seed = s - 1 def rand(): global seed seed = (0x5851F42D4C957F2D * seed + 1) \u0026amp; 0xffffffffffffffff return seed \u0026gt;\u0026gt; 0x21 for t in range(1714521600, 1717200000): srand(t) msg = [] for c in data: rand_num = rand() msg.append(c ^ (rand_num % 0x7f)) msg = bytes(msg) if b\u0026#34;PWNME\u0026#34; in msg: print(msg)\rRunning this will give us the flag: PWNME{4baf3723f62a15f22e86d57130bc40c3}\nC4 License\r#\rUsing the license of \u0026lsquo;Noa\u0026rsquo; and the provided binary, develop a keygen to create a valid license for the 100 requested users.\nAuthor : Fayred\nFlag format: PWNME{.........................}\nConnect : nc --ssl [Host] 443\nWe are given two files: A binary executable and a sample license for a user named Noa.\nRunning the binary will show us a form. Typing in an invalid license, we\u0026rsquo;ll get Invalid license key. If we use the sample license, we\u0026rsquo;ll get Congratulation, your license key is valid !\nThere are a lot of functions, so it might be a good idea to look for the string Invalid license key in the file.\nTo find a string in IDA, we can use Ctrl+F for IDA 9.0, or Alt+T for older versions.\rWe can see that it\u0026rsquo;s used in the function C4License::on_checkKey_clicked. This function will base64 decrypt our license and get user and serial from the decrypted JSON string. These will be passed to the checker function, which checks the values as follows:\nFirst, it uses the crc32 checksum of user (which is a1) to set the seed through srand. Then, it generates two random numbers to make the key v26, which is used as the key for RC4 decryption: v3 = *((unsigned int *)a1 + 2); v4 = *a1; v27 = __readfsqword(0x28u); v5 = crc32(0LL, v4, v3); srand(v5); v6 = rand(); *(_DWORD *)v26 = _byteswap_ulong(rand() % 0xFFFF * (v6 % 0xFFFF)); RC4::RC4((RC4 *)v25, v26);\rAfter that, it will hex decode the serial (a2) and RC4 decrypt it using the key above. The result will be stored in v22 RC4::RC4((RC4 *)v25, v26); QByteArray::fromHex((QByteArray *)\u0026amp;v24, a2); RC4::decrypt(\u0026amp;v22, v25, \u0026amp;v24);\rFinally, it will compare the SHA1 checksum of v22 and compare it with b039d6daea04c40874f80459bff40142bd25b995. The hash is not crackable, but through debugging using the sample license, we see that v22 is PwNmE_c4_message!137.\nFrom this, we can write a script that takes 100 username from the server and generate the licenses:\nDetails from base64 import b64encode, b64decode from Crypto.Cipher import ARC4 from ctypes import CDLL from zlib import crc32 from pwn import * import time libc = CDLL(\u0026#34;libc.so.6\u0026#34;) def gen_license(username): username = username.encode() seed = crc32(username) print(hex(seed)) libc.srand(seed) n1 = libc.rand() n2 = libc.rand() n = (n1 % 0xffff) * (n2 % 0xffff) print(hex(n)) rc4_key = bytes.fromhex(hex(n).replace(\u0026#34;0x\u0026#34;, \u0026#39;\u0026#39;).zfill(8)) print(\u0026#34;key:\u0026#34; , rc4_key.hex()) rc4 = ARC4.new(rc4_key) enc = rc4.encrypt(b\u0026#34;PwNmE_c4_message!137\u0026#34;) password = enc.hex() license = f\u0026#39;{{\u0026#34;user\u0026#34;:\u0026#34;{username.decode()}\u0026#34;,\u0026#34;serial\u0026#34;:\u0026#34;{password}\u0026#34;}}\u0026#39; print(license) return b64encode(license.encode()).decode() # print(gen_license(\u0026#34;Noa\u0026#34;).decode()) p = remote(\u0026#34;c4license-90c9d36428b43675.deploy.phreaks.fr\u0026#34;, 443, ssl=True) # context.log_level = \u0026#39;debug\u0026#39; for i in range(100): msg = p.recvuntil(b\u0026#34;user :\u0026#34;).decode() print(msg) username = msg.split(\u0026#34;Your license for \u0026#34;)[1].split(\u0026#34; user\u0026#34;)[0].strip() print(username) license = gen_license(username) p.sendline(license.encode()) time.sleep(0.5) p.interactive()\rMimirev\r#\rA new and obscure programming language, MimiLang, has surfaced. It runs on a peculiar interpreter, but something about it feelsâ€¦ off. Dive into its inner workings and figure out what\u0026rsquo;s really going on. Maybe you\u0026rsquo;ll uncover something unexpected.\nAuthor : Lxt3h\nFlag format: PWNME{.........................}\nWe are given a binary executable which runs the code in a .mimi file. Let\u0026rsquo;s look in IDA!\nIt seems like it\u0026rsquo;s a Golang binary. When analysing a non-stripped Golang or Rust file, the first thing that I do is looking for interesting function names:\nWell look at that, there is a github_com_Lexterl33t_mimicompiler_vm_decryptFlag function. And it\u0026rsquo;s used by github_com_Lexterl33t_mimicompiler_vm__ptr_VM_VerifyProof.\nAnalysing the function, we see that the function does the following:\nIt pops two values x and y from the stack and checks some constraints: x + y == 314159 (x * x + y * y * y - x * y) % 1048573 == 273262\rIf x and y satisfy the constraints, they will be formatted as %d:%d. Then the function takes the SHA256 sum of this to decrypt the flag using github_com_Lexterl33t_mimicompiler_vm_decryptFlag: v30 = runtime_convT64(x, v24, v25, 1, 1, v26, v27, v28, v29, v69); *(_QWORD *)\u0026amp;v93 = \u0026#34;\\b\u0026#34;; *((_QWORD *)\u0026amp;v93 + 1) = v30; v36 = runtime_convT64(y, v24, v31, 1, 1, v32, v33, v34, v35, v70); *(_QWORD *)\u0026amp;v94 = \u0026#34;\\b\u0026#34;; *((_QWORD *)\u0026amp;v94 + 1) = v36; v41 = fmt_Sprintf((unsigned int)\u0026#34;%d:%d\u0026#34;, 5, (unsigned int)\u0026amp;v93, 2, 2, v37, v38, v39, v40, v71, v76, v79, v84); v46 = runtime_stringtoslicebyte((unsigned int)\u0026amp;v87, v41, 5, 2, 2, v42, v43, v44, v45, v72, v77, v80); crypto_sha256_Sum256(v46, v41, v47, 2, 2, v48, v49, v50, v51, v73, v81, v85); v86[0] = v74; v86[1] = v82; v52 = a1[8]; v56 = github_com_Lexterl33t_mimicompiler_vm_decryptFlag( (__int64)a1[7], (signed __int64)v52, (__int64)a1[9], (__int64)v86, 16LL, 32, v53, v54, v55);\rI will not try to explain github_com_Lexterl33t_mimicompiler_vm_decryptFlag fully, but it seems like the SHA256 checksum is used as the key for AES decryption (the first 16 bytes). So what is being decrypted here?\nWe haven\u0026rsquo;t even looked at the main function yet. In the main function, there is a part where it creates a new VM:\nv170 = github_com_Lexterl33t_mimicompiler_vm_NewVM( v79, (_DWORD)v52, v80, (unsigned int)\u0026#34;mTfYS2+3UoKAO+gueELVdxNc6QDBwKW1t8uN5Dx/HIGvWb7kMtmLoyt6SB0EIw39\u0026#34;, 64, (unsigned int)\u0026#34;11466b4b07a438fdba619b86088353976073d790344cbf4dae99512028808ecf\u0026#34;, 64, v83, v84, v125, v136, v143, v149, v153, v154);\rLooking at this function, there are some interesting stuffs:\n__int64 __golang github_com_Lexterl33t_mimicompiler_vm_NewVM( __int64 a1, __int64 a2, __int64 a3, __int64 sus_base64, int _64, __int64 sus_hex, __int64 _64__, int a8, int a9) { // variables ... v30 = encoding_base64__ptr_Encoding_DecodeString( qword_5A57B8, sus_base64, _64, sus_base64, _64, sus_hex, _64__, a8, a9); // ... if ( dword_5C5970 ) { result = runtime_gcWriteBarrier4(); v23 = a1; *v27 = a1; v24 = v31; v27[1] = v31; base64_decrypted = v30; v27[2] = v30; sus_hex_ = sus_hex; v27[3] = sus_hex; } else { v23 = a1; v24 = v31; base64_decrypted = v30; sus_hex_ = sus_hex; } *(_QWORD *)(result + 24) = v23; *(_QWORD *)(result + 48) = v24; *(_QWORD *)(result + 64) = sus_base64; *(_QWORD *)(result + 72) = v28; *(_QWORD *)(result + 56) = base64_decrypted; *(_QWORD *)(result + 88) = _64__; *(_QWORD *)(result + 80) = sus_hex_; return result; }\rWe can see that base64 string is decrypted and stored in result[7] (result + 56). Looking back at github_com_Lexterl33t_mimicompiler_vm_decryptFlag, we can see that this is used as the first argument. The hex string isn\u0026rsquo;t used in this function tho, so maybe it\u0026rsquo;s AES ECB.\nWith the informations that we have, let\u0026rsquo;s try to decrypt the flag! First, we need to find x and y. We can write a quick script to brute-force the solution:\nfrom hashlib import sha256 for x in range(314159+1): y = 314159 - x if (x * x + y * y * y - x * y) % 1048573 == 273262: key = f\u0026#34;{x}:{y}\u0026#34; hash = sha256(key.encode()).hexdigest() print(key)\r123456:190703 b9b6c6cd17cdb9bc1ff86179883e65116555b6766df2498281cd331366eae5d3 206712:107447 82bd2f75c8fb42d505bbd5b97b0d110f67f493ff74b16d247abbf34f01276459\rWe get two keys. Trying each key (the first 16 bytes), we can see that the first one gives the flag:\nSuper secure network\r#\rI actually did this challenge with my friends jitensha69 and severus. You can see severus\u0026rsquo;s writeup for this challenge here\nMisc\r#\rDecode Runner\r#\rWelcome to Decode Runner ! You will receive 100 encoded words. Your goal is to decode them and send back the decoded word. You have 3 seconds to respond to each word. Good luck!\nAuthor : Offpath\nFlag format: PWNME{.........................}\nConnect : nc --ssl [host] 443\nI did this challenge with my friend KangTheConq. There are a lot of ciphers used here (about 10 ciphers). Let\u0026rsquo;s walk through each of them:\nLatin Gibberish Cipher: hint: what is this charabia ??? cipher: siruosus\rI asked GPT and it said that charabia is gibberish in French. Googling gibberish cipher returns Latin Gibberish Cipher. It basically reverses the word and add some suffix.\nTo decrypt this, just remove the last two letters and reverse the string:\ndef latin_gibberish(s): data = s[:-2] return data[::-1]\rWabun code (Japanese Morse): hint: It looks like Morse code, but ... cipher: f .- g\rAt first, it seems like this is just Morse code. But when submitting the decoded word, the server saids wrong answer.\nSo what kind of Morse code is this? Turns out, there is another Morse code type named Wabun code. It encode Japanese words using Morse code. I wrote a dirty script to decrypt this (This might not always return the correct result, but it works lol):\nDetails def wabi_sabi(ciphertext): qod6 = { # Row 1 \u0026#34;A\u0026#34;: \u0026#34;--.--\u0026#34;, \u0026#34;I\u0026#34;: \u0026#34;.-\u0026#34;, \u0026#34;U\u0026#34;: \u0026#34;..-\u0026#34;, \u0026#34;E\u0026#34;: \u0026#34;-.---\u0026#34;, \u0026#34;O\u0026#34;: \u0026#34;.-...\u0026#34;, \u0026#34;N\u0026#34;: \u0026#34;.-.-.\u0026#34;, # Row 2 \u0026#34;KA\u0026#34;: \u0026#34;.-..\u0026#34;, \u0026#34;KI\u0026#34;: \u0026#34;-.-..\u0026#34;, \u0026#34;KU\u0026#34;: \u0026#34;...-\u0026#34;, \u0026#34;KE\u0026#34;: \u0026#34;-.--\u0026#34;, \u0026#34;KO\u0026#34;: \u0026#34;----\u0026#34;, # Row 3 \u0026#34;SA\u0026#34;: \u0026#34;-.-.-\u0026#34;, \u0026#34;SHI\u0026#34;: \u0026#34;--.-.\u0026#34;, \u0026#34;SU\u0026#34;: \u0026#34;---.-\u0026#34;, \u0026#34;SE\u0026#34;: \u0026#34;.---.\u0026#34;, \u0026#34;SO\u0026#34;: \u0026#34;---.\u0026#34;, # # Row 4 # \u0026#34;ZA\u0026#34;: \u0026#34;-.-.\u0026#34;, # \u0026#34;ZI\u0026#34;: \u0026#34;-.--\u0026#34;, # \u0026#34;ZU\u0026#34;: \u0026#34;..--\u0026#34;, # \u0026#34;ZE\u0026#34;: \u0026#34;.--.\u0026#34;, # \u0026#34;ZO\u0026#34;: \u0026#34;---.\u0026#34;, # Row 5 \u0026#34;TA\u0026#34;: \u0026#34;-.\u0026#34;, \u0026#34;CHI\u0026#34;: \u0026#34;..-.\u0026#34;, \u0026#34;TSU\u0026#34;: \u0026#34;.--.\u0026#34;, \u0026#34;TE\u0026#34;: \u0026#34;.-.--\u0026#34;, \u0026#34;TO\u0026#34;: \u0026#34;..-..\u0026#34;, # # Row 6 # \u0026#34;DA\u0026#34;: \u0026#34;-.\u0026#34;, # \u0026#34;DI\u0026#34;: \u0026#34;----\u0026#34;, # \u0026#34;DU\u0026#34;: \u0026#34;--.-\u0026#34;, # \u0026#34;DE\u0026#34;: \u0026#34;-..-\u0026#34;, # \u0026#34;DO\u0026#34;: \u0026#34;--..\u0026#34;, # Row 7 \u0026#34;NA\u0026#34;: \u0026#34;.-.\u0026#34;, \u0026#34;NI\u0026#34;: \u0026#34;-.-.\u0026#34;, \u0026#34;NU\u0026#34;: \u0026#34;....\u0026#34;, \u0026#34;NE\u0026#34;: \u0026#34;--.-\u0026#34;, \u0026#34;NO\u0026#34;: \u0026#34;..--\u0026#34;, # Row 8 \u0026#34;HA\u0026#34;: \u0026#34;-...\u0026#34;, \u0026#34;HI\u0026#34;: \u0026#34;--..-\u0026#34;, \u0026#34;FU\u0026#34;: \u0026#34;--..\u0026#34;, \u0026#34;HE\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;HO\u0026#34;: \u0026#34;-..\u0026#34;, # # Row 9 # \u0026#34;BA\u0026#34;: \u0026#34;.-..-\u0026#34;, # \u0026#34;BI\u0026#34;: \u0026#34;.-...\u0026#34;, # \u0026#34;BU\u0026#34;: \u0026#34;..-..\u0026#34;, # \u0026#34;BE\u0026#34;: \u0026#34;....\u0026#34;, # \u0026#34;BO\u0026#34;: \u0026#34;.--..\u0026#34;, # # Row 10 # \u0026#34;PA\u0026#34;: \u0026#34;.-..-\u0026#34;, # \u0026#34;PI\u0026#34;: \u0026#34;.-...\u0026#34;, # \u0026#34;PU\u0026#34;: \u0026#34;..-..\u0026#34;, # \u0026#34;PE\u0026#34;: \u0026#34;....\u0026#34;, # \u0026#34;PO\u0026#34;: \u0026#34;.--..\u0026#34;, # Row 11 \u0026#34;MA\u0026#34;: \u0026#34;-..-\u0026#34;, \u0026#34;MI\u0026#34;: \u0026#34;..-.-\u0026#34;, \u0026#34;MU\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;ME\u0026#34;: \u0026#34;-...-\u0026#34;, \u0026#34;MO\u0026#34;: \u0026#34;-..-.\u0026#34;, # Row 12 \u0026#34;YA\u0026#34;: \u0026#34;.--\u0026#34;, \u0026#34;YU\u0026#34;: \u0026#34;-..--\u0026#34;, \u0026#34;YO\u0026#34;: \u0026#34;--\u0026#34;, \u0026#34;RA\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;RI\u0026#34;: \u0026#34;--.\u0026#34;, \u0026#34;RU\u0026#34;: \u0026#34;-.--.\u0026#34;, \u0026#34;RE\u0026#34;: \u0026#34;---\u0026#34;, \u0026#34;RO\u0026#34;: \u0026#34;.-.-\u0026#34;, \u0026#34;WA\u0026#34;: \u0026#34;-.-\u0026#34;, \u0026#34;WI\u0026#34;: \u0026#34;.-..-\u0026#34;, \u0026#34;WE\u0026#34;: \u0026#34;.--..\u0026#34;, \u0026#34;WO\u0026#34;: \u0026#34;.---\u0026#34;, } DICT = {} for key, value in qod6.items(): DICT[value] = key ciphertext = ciphertext.split() ans = \u0026#39;\u0026#39; for word in ciphertext: if \u0026#39;.\u0026#39; in word or \u0026#39;-\u0026#39; in word: ans += DICT[word] else: ans += word return ans.lower()\rFirst Letter: cipher: India Golf Uniform Alfa November Oscar Delta Oscar November\rThere isn\u0026rsquo;t a hint for this one. We can solve this by taking the first letter of each word to form a new word:\ndef first_letter(s): s = s.split() s = [i[0] for i in s] s = \u0026#34;\u0026#34;.join(s) return s.lower()\rChord cipher: hint: Hendrix would have had it... cipher: x24442 x02220 xx0232 320003 022100 xx0232\rA quick Google shows that Jimi Hendrix is an American guitarist and songwriter. Moreover, the cipher looks like guitar chord, so this might be Chord cipher:\ndef chord_cipher(ciphertext): ciphertext = ciphertext.split() dict = {\u0026#34;x02220\u0026#34;: \u0026#39;a\u0026#39;, \u0026#34;224442\u0026#34;:\u0026#39;b\u0026#39;, \u0026#39;032010\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;xx0232\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;022100\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;133211\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;320003\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;x24442\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;x32010\u0026#39;:\u0026#39;c\u0026#39;} ans = \u0026#39;\u0026#39; for i in ciphertext: ans += dict.get(i, \u0026#39;?\u0026#39;) return ans\rBaudot Code hint: He can\u0026#39;t imagine finding himself in CTF 150 years later... cipher: 01111 11000 00011 10010 00011\rThis looks like Morse code, but each \u0026ldquo;word\u0026rdquo; is only 5-digit long. A quick ChatGPT gives Baudot Code:\nbaudot_table = { \u0026#34;00000\u0026#34;: \u0026#34;null\u0026#34;, \u0026#34;00100\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;10111\u0026#34;: \u0026#34;Q\u0026#34;, \u0026#34;10011\u0026#34;: \u0026#34;W\u0026#34;, \u0026#34;00001\u0026#34;: \u0026#34;E\u0026#34;, \u0026#34;01010\u0026#34;: \u0026#34;R\u0026#34;, \u0026#34;10000\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;10101\u0026#34;: \u0026#34;Y\u0026#34;, \u0026#34;00111\u0026#34;: \u0026#34;U\u0026#34;, \u0026#34;00110\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;11000\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;10110\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;00011\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;00101\u0026#34;: \u0026#34;S\u0026#34;, \u0026#34;01001\u0026#34;: \u0026#34;D\u0026#34;, \u0026#34;01101\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;11010\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;10100\u0026#34;: \u0026#34;H\u0026#34;, \u0026#34;01011\u0026#34;: \u0026#34;J\u0026#34;, \u0026#34;01111\u0026#34;: \u0026#34;K\u0026#34;, \u0026#34;10010\u0026#34;: \u0026#34;L\u0026#34;, \u0026#34;10001\u0026#34;: \u0026#34;Z\u0026#34;, \u0026#34;11101\u0026#34;: \u0026#34;X\u0026#34;, \u0026#34;01110\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;11110\u0026#34;: \u0026#34;V\u0026#34;, \u0026#34;11001\u0026#34;: \u0026#34;B\u0026#34;, \u0026#34;01100\u0026#34;: \u0026#34;N\u0026#34;, \u0026#34;11100\u0026#34;: \u0026#34;M\u0026#34;, \u0026#34;01000\u0026#34;: \u0026#34;CR\u0026#34;, \u0026#34;00010\u0026#34;: \u0026#34;LF\u0026#34;, \u0026#34;11011\u0026#34;: \u0026#34;Switch to Digits\u0026#34; } def baudot_decode(ciphertext): bits = ciphertext.split() decoded_text = \u0026#34;\u0026#34;.join(baudot_table.get(bit, \u0026#34;?\u0026#34;) for bit in bits) return decoded_text.lower()\rTrimethius Cipher: hint: Born in 1462 in Germany... cipher: rmxksmc\rGoogling the hint gives Johannes Trithemius. Googling the cipher gives Trimethius Cipher.\nWe can use Try all shifts (bruteforce) on dcode and we\u0026rsquo;ll see that offset +3 gives meaningful words. I wrote a script for this:\ndef trimethius_decode(ciphertext): ALPHABET = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.lower() offset = 3 ans = \u0026#34;\u0026#34; for i in range(len(ciphertext)): idx = ALPHABET.index(ciphertext[i]) ans += ALPHABET[(idx - offset + len(ALPHABET)) % len(ALPHABET)] offset += 1 return ans\rChuck Norris Unary Code hint: He can snap his toes, and has already counted to infinity twice ... cipher: 0 0000 00 000 0 0000 00 00 0 000 00 0 0 00 00 00 0 00 00 0 0 000000 00 000 0 0000 00 0 0 0000000 00 0000 0 00 00 00 0 0 00 0 0 0\rMy friend KangTheConq found out that this is Chuck Norris Unary Code, and he writes the decoding script too:\ndef decode_chuck_norris(unary_code): parts = unary_code.split() binary_string = \u0026#34;\u0026#34; for i in range(0, len(parts), 2): bit = \u0026#39;1\u0026#39; if parts[i] == \u0026#39;0\u0026#39; else \u0026#39;0\u0026#39; binary_string += bit * len(parts[i + 1]) decoded_text = \u0026#34;\u0026#34; for i in range(0, len(binary_string), 7): decoded_text += chr(int(binary_string[i:i+7], 2)) return decoded_text\rShankar Speech Defect hint: Did you realy see slumdog millionaire ? cipher: PJWX\rGoogling slumdog millionaire cipher gives Shankar Speech Defect. It\u0026rsquo;s just another substitution cipher:\ndef slumdog(ciphertext): cipheralphabet = \u0026#39;XWYAZBCDQEFGHIKLMNOPJRSTUV\u0026#39; plainalphabet = string.ascii_uppercase plaintext = \u0026#39;\u0026#39; for c in ciphertext: if c == \u0026#39; \u0026#39;: p = \u0026#39; \u0026#39; else: p = plainalphabet[cipheralphabet.index(c)] plaintext += p return plaintext.lower()\rMorbit Cipher: hint: A code based on pairs of dots and dashes. Think of a mix of Morse code and numbers... (AZERTYUIO) cipher: 2557122917522\rKangTheConq clutched again and found out that this is Morbit Cipher:\nMORSE_CODE_DICT = {\u0026#39;..-\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;--..--\u0026#39;: \u0026#39;, \u0026#39;, \u0026#39;....-\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;.....\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;-...\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;-..-\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;.-.\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;--.-\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;--..\u0026#39;: \u0026#39;Z\u0026#39;, \u0026#39;.--\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;-..-.\u0026#39;: \u0026#39;/\u0026#39;, \u0026#39;..---\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;.-\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;..\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;-.-.\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;..-.\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;---\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;-.--\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;-\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;.\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;.-..\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;...\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;-.--.-\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;..--..\u0026#39;: \u0026#39;?\u0026#39;, \u0026#39;.----\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;-----\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;-.-\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;-..\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;----.\u0026#39;: \u0026#39;9\u0026#39;, \u0026#39;-....\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;.---\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;.--.\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;.-.-.-\u0026#39;: \u0026#39;.\u0026#39;, \u0026#39;-.--.\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;--\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;-.\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;....\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;---..\u0026#39;: \u0026#39;8\u0026#39;, \u0026#39;...-\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;--...\u0026#39;: \u0026#39;7\u0026#39;, \u0026#39;--.\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;...--\u0026#39;: \u0026#39;3\u0026#39;, \u0026#39;-....-\u0026#39;: \u0026#39;-\u0026#39;} MORBIT = [\u0026#39;..\u0026#39;, \u0026#39;. \u0026#39;, \u0026#39; -\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;-.\u0026#39;, \u0026#39;--\u0026#39;, \u0026#39; .\u0026#39;, \u0026#39;- \u0026#39;, \u0026#39;.-\u0026#39;] KEY = \u0026#34;AZERTYUIO\u0026#34; # Given key # Map digits to Morbit symbols using the key MORBIT_CODE_DICT = dict(zip(\u0026#34;123456789\u0026#34;, MORBIT)) def morse(ciphertxt): \u0026#34;\u0026#34;\u0026#34; Decodes a Morse code string to plaintext. \u0026#34;\u0026#34;\u0026#34; plaintxt = \u0026#39;\u0026#39; for word in ciphertxt.strip().split(\u0026#34; \u0026#34;): for c in word.strip().split(\u0026#34; \u0026#34;): if c in MORSE_CODE_DICT: plaintxt += MORSE_CODE_DICT[c] plaintxt += \u0026#39; \u0026#39; return plaintxt.strip() def morbit(ciphertxt): \u0026#34;\u0026#34;\u0026#34; Decodes a Morbit cipher text into Morse code, then to plaintext. \u0026#34;\u0026#34;\u0026#34; morsetxt = \u0026#34;\u0026#34;.join(MORBIT_CODE_DICT[c] for c in ciphertxt if c in MORBIT_CODE_DICT) return morse(morsetxt).lower()\rCombining all of this, we get this final script:\nDetails from pwn import * import string HOST = \u0026#39;decoderunner-6bf56818dcc9ea04.deploy.phreaks.fr\u0026#39; PORT = 443 p = remote(HOST, PORT, ssl=True) # p = remote(HOST, PORT) def latin_gibberish(s): data = s[:-2] return data[::-1] def decode_1337(s): leet_dict = { \u0026#39;4\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;/\\\\\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;@\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;/-\\\\\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;|3\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;13\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;(\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;\u0026lt;\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;[\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;Â©\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;[)\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;|\u0026gt;\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;|)\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;â‚¬\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;[-\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;|=\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;/=\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;6\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;(_+\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;#\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;/-/\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;[-]\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;]-[\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;)-(\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;(-)\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;|-|\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;I\u0026#39;, \u0026#34;1\u0026#39;\u0026#34;: \u0026#39;I\u0026#39;, \u0026#39;!\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;|\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;_|\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;_/\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;|\u0026lt;\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;|{\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;|_\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;[\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;Â£\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;1_\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;|V|\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;|\\/|\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;/\\/\\\\\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;/V\\\\\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;|\\|\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;/\\/\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;[\\]\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;/V\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;[]\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;()\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;\u0026lt;\u0026gt;\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;|*\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;|o\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;|Â°\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;/*\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;()_\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;0_\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;Â°|\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;(_,)\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;|?\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;Â®\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;|2\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;5\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;$\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;Â§\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;â€ \u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;Â¯|Â¯\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;(_)\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;|_|\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;Âµ\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;\\/\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;|/\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;\\/\\/\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;vv\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;\\^/\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;\\|/\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;\\_|_/\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;\u0026gt;\u0026lt;\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;)(\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;`/\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;Â¥\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;\\/\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#34;7_\u0026#39;\u0026#34;: \u0026#39;Z\u0026#39;, \u0026#39;\u0026gt;_\u0026#39;: \u0026#39;Z\u0026#39;, \u0026#39;â‰¥\u0026#39;: \u0026#39;Z\u0026#39; } result = s for leet, char in sorted(leet_dict.items(), key=lambda x: -len(x[0])): result = result.replace(leet, char) return result.lower() def slumdog(ciphertext): cipheralphabet = \u0026#39;XWYAZBCDQEFGHIKLMNOPJRSTUV\u0026#39; plainalphabet = string.ascii_uppercase plaintext = \u0026#39;\u0026#39; for c in ciphertext: if c == \u0026#39; \u0026#39;: p = \u0026#39; \u0026#39; else: p = plainalphabet[cipheralphabet.index(c)] plaintext += p return plaintext.lower() def weird_morse(s): MORSE_CODE_DICT = { \u0026#39;A\u0026#39;:\u0026#39;.-\u0026#39;, \u0026#39;B\u0026#39;:\u0026#39;-...\u0026#39;, \u0026#39;C\u0026#39;:\u0026#39;-.-.\u0026#39;, \u0026#39;D\u0026#39;:\u0026#39;-..\u0026#39;, \u0026#39;E\u0026#39;:\u0026#39;.\u0026#39;, \u0026#39;F\u0026#39;:\u0026#39;..-.\u0026#39;, \u0026#39;G\u0026#39;:\u0026#39;--.\u0026#39;, \u0026#39;H\u0026#39;:\u0026#39;....\u0026#39;, \u0026#39;I\u0026#39;:\u0026#39;..\u0026#39;, \u0026#39;J\u0026#39;:\u0026#39;.---\u0026#39;, \u0026#39;K\u0026#39;:\u0026#39;-.-\u0026#39;, \u0026#39;L\u0026#39;:\u0026#39;.-..\u0026#39;, \u0026#39;M\u0026#39;:\u0026#39;--\u0026#39;, \u0026#39;N\u0026#39;:\u0026#39;-.\u0026#39;, \u0026#39;O\u0026#39;:\u0026#39;---\u0026#39;, \u0026#39;P\u0026#39;:\u0026#39;.--.\u0026#39;, \u0026#39;Q\u0026#39;:\u0026#39;--.-\u0026#39;, \u0026#39;R\u0026#39;:\u0026#39;.-.\u0026#39;, \u0026#39;S\u0026#39;:\u0026#39;...\u0026#39;, \u0026#39;T\u0026#39;:\u0026#39;-\u0026#39;, \u0026#39;U\u0026#39;:\u0026#39;..-\u0026#39;, \u0026#39;V\u0026#39;:\u0026#39;...-\u0026#39;, \u0026#39;W\u0026#39;:\u0026#39;.--\u0026#39;, \u0026#39;X\u0026#39;:\u0026#39;-..-\u0026#39;, \u0026#39;Y\u0026#39;:\u0026#39;-.--\u0026#39;, \u0026#39;Z\u0026#39;:\u0026#39;--..\u0026#39;, \u0026#39;1\u0026#39;:\u0026#39;.----\u0026#39;, \u0026#39;2\u0026#39;:\u0026#39;..---\u0026#39;, \u0026#39;3\u0026#39;:\u0026#39;...--\u0026#39;, \u0026#39;4\u0026#39;:\u0026#39;....-\u0026#39;, \u0026#39;5\u0026#39;:\u0026#39;.....\u0026#39;, \u0026#39;6\u0026#39;:\u0026#39;-....\u0026#39;, \u0026#39;7\u0026#39;:\u0026#39;--...\u0026#39;, \u0026#39;8\u0026#39;:\u0026#39;---..\u0026#39;, \u0026#39;9\u0026#39;:\u0026#39;----.\u0026#39;, \u0026#39;0\u0026#39;:\u0026#39;-----\u0026#39;, \u0026#39;, \u0026#39;:\u0026#39;--..--\u0026#39;, \u0026#39;.\u0026#39;:\u0026#39;.-.-.-\u0026#39;, \u0026#39;?\u0026#39;:\u0026#39;..--..\u0026#39;, \u0026#39;/\u0026#39;:\u0026#39;-..-.\u0026#39;, \u0026#39;-\u0026#39;:\u0026#39;-....-\u0026#39;, \u0026#39;(\u0026#39;:\u0026#39;-.--.\u0026#39;, \u0026#39;)\u0026#39;:\u0026#39;-.--.-\u0026#39;} MORSE_CODE_DICT_DECODE = {} for key, value in MORSE_CODE_DICT.items(): MORSE_CODE_DICT_DECODE[value] = key ans = \u0026#34;\u0026#34; s = s.split() for c in s: if \u0026#34;-\u0026#34; in c or \u0026#34;.\u0026#34; in c: c = c.replace(\u0026#34;-\u0026#34;, \u0026#39;#\u0026#39;).replace(\u0026#34;.\u0026#34;, \u0026#39;-\u0026#39;).replace(\u0026#34;#\u0026#34;, \u0026#39;.\u0026#39;) ans += MORSE_CODE_DICT_DECODE[c] else: ans += c return ans def first_letter(s): s = s.split() s = [i[0] for i in s] s = \u0026#34;\u0026#34;.join(s) return s.lower() def decode_chuck_norris(unary_code): parts = unary_code.split() binary_string = \u0026#34;\u0026#34; for i in range(0, len(parts), 2): bit = \u0026#39;1\u0026#39; if parts[i] == \u0026#39;0\u0026#39; else \u0026#39;0\u0026#39; binary_string += bit * len(parts[i + 1]) decoded_text = \u0026#34;\u0026#34; for i in range(0, len(binary_string), 7): decoded_text += chr(int(binary_string[i:i+7], 2)) return decoded_text MORSE_CODE_DICT = {\u0026#39;..-\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;--..--\u0026#39;: \u0026#39;, \u0026#39;, \u0026#39;....-\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;.....\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;-...\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;-..-\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;.-.\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;--.-\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;--..\u0026#39;: \u0026#39;Z\u0026#39;, \u0026#39;.--\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;-..-.\u0026#39;: \u0026#39;/\u0026#39;, \u0026#39;..---\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;.-\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;..\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;-.-.\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;..-.\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;---\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;-.--\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;-\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;.\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;.-..\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;...\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;-.--.-\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;..--..\u0026#39;: \u0026#39;?\u0026#39;, \u0026#39;.----\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;-----\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;-.-\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;-..\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;----.\u0026#39;: \u0026#39;9\u0026#39;, \u0026#39;-....\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;.---\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;.--.\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;.-.-.-\u0026#39;: \u0026#39;.\u0026#39;, \u0026#39;-.--.\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;--\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;-.\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;....\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;---..\u0026#39;: \u0026#39;8\u0026#39;, \u0026#39;...-\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;--...\u0026#39;: \u0026#39;7\u0026#39;, \u0026#39;--.\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;...--\u0026#39;: \u0026#39;3\u0026#39;, \u0026#39;-....-\u0026#39;: \u0026#39;-\u0026#39;} MORBIT = [\u0026#39;..\u0026#39;, \u0026#39;. \u0026#39;, \u0026#39; -\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;-.\u0026#39;, \u0026#39;--\u0026#39;, \u0026#39; .\u0026#39;, \u0026#39;- \u0026#39;, \u0026#39;.-\u0026#39;] KEY = \u0026#34;AZERTYUIO\u0026#34; # Given key # Map digits to Morbit symbols using the key MORBIT_CODE_DICT = dict(zip(\u0026#34;123456789\u0026#34;, MORBIT)) def morse(ciphertxt): \u0026#34;\u0026#34;\u0026#34; Decodes a Morse code string to plaintext. \u0026#34;\u0026#34;\u0026#34; plaintxt = \u0026#39;\u0026#39; for word in ciphertxt.strip().split(\u0026#34; \u0026#34;): for c in word.strip().split(\u0026#34; \u0026#34;): if c in MORSE_CODE_DICT: plaintxt += MORSE_CODE_DICT[c] plaintxt += \u0026#39; \u0026#39; return plaintxt.strip() def morbit(ciphertxt): \u0026#34;\u0026#34;\u0026#34; Decodes a Morbit cipher text into Morse code, then to plaintext. \u0026#34;\u0026#34;\u0026#34; morsetxt = \u0026#34;\u0026#34;.join(MORBIT_CODE_DICT[c] for c in ciphertxt if c in MORBIT_CODE_DICT) return morse(morsetxt).lower() baudot_table = { \u0026#34;00000\u0026#34;: \u0026#34;null\u0026#34;, \u0026#34;00100\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;10111\u0026#34;: \u0026#34;Q\u0026#34;, \u0026#34;10011\u0026#34;: \u0026#34;W\u0026#34;, \u0026#34;00001\u0026#34;: \u0026#34;E\u0026#34;, \u0026#34;01010\u0026#34;: \u0026#34;R\u0026#34;, \u0026#34;10000\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;10101\u0026#34;: \u0026#34;Y\u0026#34;, \u0026#34;00111\u0026#34;: \u0026#34;U\u0026#34;, \u0026#34;00110\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;11000\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;10110\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;00011\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;00101\u0026#34;: \u0026#34;S\u0026#34;, \u0026#34;01001\u0026#34;: \u0026#34;D\u0026#34;, \u0026#34;01101\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;11010\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;10100\u0026#34;: \u0026#34;H\u0026#34;, \u0026#34;01011\u0026#34;: \u0026#34;J\u0026#34;, \u0026#34;01111\u0026#34;: \u0026#34;K\u0026#34;, \u0026#34;10010\u0026#34;: \u0026#34;L\u0026#34;, \u0026#34;10001\u0026#34;: \u0026#34;Z\u0026#34;, \u0026#34;11101\u0026#34;: \u0026#34;X\u0026#34;, \u0026#34;01110\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;11110\u0026#34;: \u0026#34;V\u0026#34;, \u0026#34;11001\u0026#34;: \u0026#34;B\u0026#34;, \u0026#34;01100\u0026#34;: \u0026#34;N\u0026#34;, \u0026#34;11100\u0026#34;: \u0026#34;M\u0026#34;, \u0026#34;01000\u0026#34;: \u0026#34;CR\u0026#34;, \u0026#34;00010\u0026#34;: \u0026#34;LF\u0026#34;, \u0026#34;11011\u0026#34;: \u0026#34;Switch to Digits\u0026#34; } def baudot_decode(ciphertext): bits = ciphertext.split() decoded_text = \u0026#34;\u0026#34;.join(baudot_table.get(bit, \u0026#34;?\u0026#34;) for bit in bits) return decoded_text.lower() def trimethius_decode(ciphertext): ALPHABET = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.lower() offset = 3 ans = \u0026#34;\u0026#34; for i in range(len(ciphertext)): idx = ALPHABET.index(ciphertext[i]) ans += ALPHABET[(idx - offset + len(ALPHABET)) % len(ALPHABET)] offset += 1 return ans def wabi_sabi(ciphertext): qod6 = { # Row 1 \u0026#34;A\u0026#34;: \u0026#34;--.--\u0026#34;, \u0026#34;I\u0026#34;: \u0026#34;.-\u0026#34;, \u0026#34;U\u0026#34;: \u0026#34;..-\u0026#34;, \u0026#34;E\u0026#34;: \u0026#34;-.---\u0026#34;, \u0026#34;O\u0026#34;: \u0026#34;.-...\u0026#34;, \u0026#34;N\u0026#34;: \u0026#34;.-.-.\u0026#34;, # Row 2 \u0026#34;KA\u0026#34;: \u0026#34;.-..\u0026#34;, \u0026#34;KI\u0026#34;: \u0026#34;-.-..\u0026#34;, \u0026#34;KU\u0026#34;: \u0026#34;...-\u0026#34;, \u0026#34;KE\u0026#34;: \u0026#34;-.--\u0026#34;, \u0026#34;KO\u0026#34;: \u0026#34;----\u0026#34;, # Row 3 \u0026#34;SA\u0026#34;: \u0026#34;-.-.-\u0026#34;, \u0026#34;SHI\u0026#34;: \u0026#34;--.-.\u0026#34;, \u0026#34;SU\u0026#34;: \u0026#34;---.-\u0026#34;, \u0026#34;SE\u0026#34;: \u0026#34;.---.\u0026#34;, \u0026#34;SO\u0026#34;: \u0026#34;---.\u0026#34;, # # Row 4 # \u0026#34;ZA\u0026#34;: \u0026#34;-.-.\u0026#34;, # \u0026#34;ZI\u0026#34;: \u0026#34;-.--\u0026#34;, # \u0026#34;ZU\u0026#34;: \u0026#34;..--\u0026#34;, # \u0026#34;ZE\u0026#34;: \u0026#34;.--.\u0026#34;, # \u0026#34;ZO\u0026#34;: \u0026#34;---.\u0026#34;, # Row 5 \u0026#34;TA\u0026#34;: \u0026#34;-.\u0026#34;, \u0026#34;CHI\u0026#34;: \u0026#34;..-.\u0026#34;, \u0026#34;TSU\u0026#34;: \u0026#34;.--.\u0026#34;, \u0026#34;TE\u0026#34;: \u0026#34;.-.--\u0026#34;, \u0026#34;TO\u0026#34;: \u0026#34;..-..\u0026#34;, # # Row 6 # \u0026#34;DA\u0026#34;: \u0026#34;-.\u0026#34;, # \u0026#34;DI\u0026#34;: \u0026#34;----\u0026#34;, # \u0026#34;DU\u0026#34;: \u0026#34;--.-\u0026#34;, # \u0026#34;DE\u0026#34;: \u0026#34;-..-\u0026#34;, # \u0026#34;DO\u0026#34;: \u0026#34;--..\u0026#34;, # Row 7 \u0026#34;NA\u0026#34;: \u0026#34;.-.\u0026#34;, \u0026#34;NI\u0026#34;: \u0026#34;-.-.\u0026#34;, \u0026#34;NU\u0026#34;: \u0026#34;....\u0026#34;, \u0026#34;NE\u0026#34;: \u0026#34;--.-\u0026#34;, \u0026#34;NO\u0026#34;: \u0026#34;..--\u0026#34;, # Row 8 \u0026#34;HA\u0026#34;: \u0026#34;-...\u0026#34;, \u0026#34;HI\u0026#34;: \u0026#34;--..-\u0026#34;, \u0026#34;FU\u0026#34;: \u0026#34;--..\u0026#34;, \u0026#34;HE\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;HO\u0026#34;: \u0026#34;-..\u0026#34;, # # Row 9 # \u0026#34;BA\u0026#34;: \u0026#34;.-..-\u0026#34;, # \u0026#34;BI\u0026#34;: \u0026#34;.-...\u0026#34;, # \u0026#34;BU\u0026#34;: \u0026#34;..-..\u0026#34;, # \u0026#34;BE\u0026#34;: \u0026#34;....\u0026#34;, # \u0026#34;BO\u0026#34;: \u0026#34;.--..\u0026#34;, # # Row 10 # \u0026#34;PA\u0026#34;: \u0026#34;.-..-\u0026#34;, # \u0026#34;PI\u0026#34;: \u0026#34;.-...\u0026#34;, # \u0026#34;PU\u0026#34;: \u0026#34;..-..\u0026#34;, # \u0026#34;PE\u0026#34;: \u0026#34;....\u0026#34;, # \u0026#34;PO\u0026#34;: \u0026#34;.--..\u0026#34;, # Row 11 \u0026#34;MA\u0026#34;: \u0026#34;-..-\u0026#34;, \u0026#34;MI\u0026#34;: \u0026#34;..-.-\u0026#34;, \u0026#34;MU\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;ME\u0026#34;: \u0026#34;-...-\u0026#34;, \u0026#34;MO\u0026#34;: \u0026#34;-..-.\u0026#34;, # Row 12 \u0026#34;YA\u0026#34;: \u0026#34;.--\u0026#34;, \u0026#34;YU\u0026#34;: \u0026#34;-..--\u0026#34;, \u0026#34;YO\u0026#34;: \u0026#34;--\u0026#34;, \u0026#34;RA\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;RI\u0026#34;: \u0026#34;--.\u0026#34;, \u0026#34;RU\u0026#34;: \u0026#34;-.--.\u0026#34;, \u0026#34;RE\u0026#34;: \u0026#34;---\u0026#34;, \u0026#34;RO\u0026#34;: \u0026#34;.-.-\u0026#34;, \u0026#34;WA\u0026#34;: \u0026#34;-.-\u0026#34;, \u0026#34;WI\u0026#34;: \u0026#34;.-..-\u0026#34;, \u0026#34;WE\u0026#34;: \u0026#34;.--..\u0026#34;, \u0026#34;WO\u0026#34;: \u0026#34;.---\u0026#34;, } DICT = {} for key, value in qod6.items(): DICT[value] = key ciphertext = ciphertext.split() ans = \u0026#39;\u0026#39; for word in ciphertext: if \u0026#39;.\u0026#39; in word or \u0026#39;-\u0026#39; in word: ans += DICT[word] else: ans += word return ans.lower() def chord_cipher(ciphertext): ciphertext = ciphertext.split() dict = {\u0026#34;x02220\u0026#34;: \u0026#39;a\u0026#39;, \u0026#34;224442\u0026#34;:\u0026#39;b\u0026#39;, \u0026#39;032010\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;xx0232\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;022100\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;133211\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;320003\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;x24442\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;x32010\u0026#39;:\u0026#39;c\u0026#39;} ans = \u0026#39;\u0026#39; for i in ciphertext: ans += dict.get(i, \u0026#39;?\u0026#39;) return ans for i in range(100): hint = p.recvuntil(b\u0026#39;cipher: \u0026#39;).decode() print(hint) cipher = p.recvline().strip().decode() print(cipher) if (\u0026#34;charabia\u0026#34; in hint): msg = latin_gibberish(cipher) print(msg) p.sendline(msg) elif (\u0026#34;1337\u0026#34; in hint): msg = decode_1337(cipher) print(msg) p.sendline(msg) elif (\u0026#34;slumdog\u0026#34; in hint): msg = slumdog(cipher) print(msg) p.sendline(msg) elif (\u0026#34;It looks like Morse code\u0026#34; in hint): msg = wabi_sabi(cipher) print(msg) p.sendline(msg) elif (\u0026#34;hint\u0026#34; not in hint): msg = first_letter(cipher) print(msg) p.sendline(msg) elif (\u0026#34;infinity twice\u0026#34; in hint): msg = decode_chuck_norris(cipher) print(msg) p.sendline(msg) elif (\u0026#34;CTF 150 years\u0026#34; in hint): msg = baudot_decode(cipher) print(msg) p.sendline(msg) elif (\u0026#34;code based on\u0026#34; in hint): msg = morbit(cipher) print(msg) p.sendline(msg) elif (\u0026#34;1462\u0026#34; in hint): msg = trimethius_decode(cipher) print(msg) p.sendline(msg) elif (\u0026#34;Hendrix\u0026#34; in hint): msg = chord_cipher(cipher) print(msg) p.sendline(msg) else: break p.interactive()\r","date":"3 March 2025","description":"Writeup for some challenges that I solved in PwnMe CTF 2025.","externalUrl":null,"permalink":"/blog/rsa/hello-world/","section":"Blogs","summary":"","title":"PwnMe CTF 2025 Writeup","type":"blog"},{"content":"","date":"3 March 2025","description":"","externalUrl":null,"permalink":"/tags/reverse-engineering/","section":"Tags","summary":"","title":"Reverse Engineering","type":"tags"},{"content":"My research posts about RSA.\n","date":"3 March 2025","description":"","externalUrl":null,"permalink":"/blog/rsa/","section":"Blogs","summary":"","title":"RSA","type":"blog"},{"content":"","date":"3 March 2025","description":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"3 March 2025","description":"","externalUrl":null,"permalink":"/","section":"The Sad Horse","summary":"","title":"The Sad Horse","type":"page"},{"content":"","date":"3 March 2025","description":"","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","description":"","externalUrl":null,"permalink":"/profile/","section":"The Sad Horse","summary":"","title":"About Me","type":"about-me"},{"content":"","description":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","description":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","description":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"My research posts about symmetric ciphers.\n","description":"","externalUrl":null,"permalink":"/blog/symmetric-cipher/","section":"Blogs","summary":"","title":"Symmetric Cipher","type":"blog"}]