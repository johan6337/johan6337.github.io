---
layout: post
title: RSA is fun (Part 1).
description:  An informal introduction about all kinds of RSA attacks.
date: '2024-09-11 10:16:00 +0700'
categories: [RSA]
tags: [RSA]
math: true
mermaid: true
---

## I) Brief introduction about RSA ##

### Definition ###

RSA (Rivest-Shamir-Adleman) is a public-key cryptosystem that is widely used for secure data transmission. It is also one of the oldest and best-known asymmetric encryption schemes. The security of RSA relies on the practical difficulty of factoring the product of two large prime numbers, the factoring problem. In this blog post, we will discuss some attack that i collected from various sources.

### RSA encryption and decryption ###

RSA involves a public key and a private key. The public key can be known by everyone and is used for encrypting messages. Messages encrypted using the public key can only be decrypted with the private key. The keys for the RSA algorithm are generated the following way:

1. Choose two distinct prime numbers $p$ and $q$.
2. Compute $n = pq$.
3. Compute $\phi(n) = (p-1)(q-1)$.
4. Choose an integer $e$ such that $1 < e < \phi(n)$ and $gcd(e, \phi(n)) = 1$.
5. Compute $d$ such that $ed \equiv 1 \pmod{\phi(n)}$.

Therefore, one can encrypt a message $m$ by computing $c \equiv m^e \pmod{n}$ and decrypt it by computing $m \equiv c^d \pmod{n}$. And now we move on to the main topic of this blog post.

## II) Attacks on RSA ##

### 1. Fermat factorization ###

**Fermat Factorization** method bases on the fact that any integers can be express as the difference of two squares. If $n$ is a number that can be expressed as **$n = a^2 - b^2$**, then **$n = (a+b)(a-b)$**. 

Fermat's factorization method factors N into p and q very efficiently if p and q share half of their leading bits. In other words, if the gap between p and q is below the $\sqrt{N}$. Especially, when the difference is below $2n^{1/4}$, the method run in trivial time.

**Python implementation**:

```python
from math import isqrt, ceil
 
def fermat_factorization(n):
    a = ceil(pow(n, 0.5))
    while True:
        b2 = a*a - n
        b = pow(b2,0.5)
        if b*b == b2:
            break
        a += 1
    return (a+b), (a-b)

n = 115792089237316195448679392282006640413199890130332179010243714077028592474181
p, q = fermat_factorization(n)
assert n == p*q
```

**Resources**: [Wikipedia](https://en.wikipedia.org/wiki/Fermat%27s_factorization_method)

### 2. Pollard's p-1 algorithm ###

Pollard's p-1 factorization method is a special-purpose method, which is only suitable for numbers with small factors. In other word, the algorithm is effient when 1 factor of n is B-smooth prime( that p - 1 is the product of several small prime).

**Example** : p = 61 is a 5-smooth prime because $p-1 = 2^2 * 3 * 5$.

**Python implementation**:

```python
from gmpy2 import gcd,fac

#step 1: choose a random number a
a = 2
n = 1403 #the factor of n (61) is smooth
#step 2: choose the bound B. In this case B = 10 is safe.
# the bound for the factor of p (generally, B is 65535), larger B run slower but more accurate, smaller B run faster but less accurate. Value of B depend on the powersmooth of p.
B = 10 

while True:
    M = fac(B) #step 3 : calculate M = B!
    d = gcd(pow(a,M,n)-1,n) #step 4: calculate d = gcd(a^M - 1, n). For understanding, read the resoure i provided below.
    if d == 1:  #if d == 1, then the smoothpower of p is higher than B so increase B
        B += 1
    elif d == n: #if d == n, then the smoothpower of p is lower than B so decrease B
        B -= 1
    else:  #if d is a factor of n, then we found the factor of n
        assert d*(n//d) == n
        print(d, n//d)
        break

```

**Resources**: [Wikipedia](https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm)

### 3. Williams' p+1 algorithm ###

William's p+1 algorithm is a generalization of Pollard's p-1 algorithm. The algorithm is suitable for numbers with small factors. The algorithm is efficient when 1 factor of n is B-smooth prime( that p + 1 is the product of several small prime).

**Example** : p = 61 is a 5-smooth prime because $p+1 = 2^2 * 3 * 5$.

**Python implementation**:

```python
from gmpy2 import fac
import itertools
from math import gcd

# function to find the Mth number in Lucas sequence generate by A. For more information, read the resource i provided below.
def Mth_lucas(M,A,N):
    x = A
    y = (A**2-2) % N
    for i in bin(M)[3:]:
        if i == '1':
            x = (x*y - A) % N
            y = (y**2 - 2) % N
        else:
            y = (x*y - A) % N
            x = (x**2 - 2) % N
    return x

# function to find the factor of n
def william_factor(N,A):
    for i in itertools.count(1): #loop through all the factorials
        x = Mth_lucas(fac(i),A,N) #calculate the fac(i) number in the lucas sequence
        d = gcd(x-2,N) #calculate the gcd of x-2 and N
        if d == 1 or d == N: 
            continue
        else: # if 1 < d < N then d is non-trivial factor of N
            return d # 
n = 451889 
A = 6  
p = william_factor(n,A)
q = n//p
assert n == p*q
```

Resources: [Wikipedia](https://en.wikipedia.org/wiki/Williams%27_p_%2B_1_algorithm)

### 4. Lenstra elliptic-curve factorization ###



















